"Line","Source","CPU Time"
"1","#include ""test_func.h""",""
"2","",""
"3","void random_malloc_free(int test_cnt, int test_cap, int max_mem)",""
"4","{",""
"5","    typedef std::map<int, char*> POINT_MAP;",""
"6","    typedef POINT_MAP::iterator POINT_MAP_ITOR;",""
"7","    POINT_MAP test_map;",""
"8","    for(int i=0; i<test_cnt; ++i)",""
"9","    {",""
"10","        int rand_id = rand() % test_cap;",""
"11","        POINT_MAP_ITOR find_part = test_map.find(rand_id);","0.3954069"
"12","        if (find_part != test_map.end())","9.4065e-003"
"13","        {",""
"14","            //printf(""free %d\n"", rand_id);",""
"15","            delete[] (find_part->second);","9.7353e-003"
"16","            test_map.erase(find_part);","8.74627e-002"
"17","        }",""
"18","        else",""
"19","        {",""
"20","            int len = rand() * rand() % max_mem;","0.1275553"
"21","            //printf(""malloc %d:%d\n"", rand_id, len);",""
"22","            char* block = new char[len];",""
"23","            test_map[rand_id] = block;","0.1667197"
"24","        }",""
"25","    }",""
"26","",""
"27","    for(POINT_MAP_ITOR it = test_map.begin(); it != test_map.end(); ++it)",""
"28","    {",""
"29","        delete[] it->second;",""
"30","    }",""
"31","}",""
"32","",""
"33","DWORD WINAPI RAMDON_MALLOC_FREE_THD(LPVOID p_param)",""
"34","{",""
"35","    RANDOM_MALLOC_FREE_ARGS* test_args = (RANDOM_MALLOC_FREE_ARGS*)p_param;",""
"36","    if (test_args == NULL) return 1;",""
"37","    random_malloc_free(test_args->test_cnt, test_args->test_cap, test_args->max_mem);","3.09092e-002"
"38","    return 0;",""
"39","}",""
"40","",""
"41","void random_malloc_free_mthd(int thd_cnt, int test_cnt, int test_cap, int max_mem)",""
"42","{",""
"43","    RANDOM_MALLOC_FREE_ARGS test_args;",""
"44","    test_args.test_cnt = test_cnt;",""
"45","    test_args.test_cap = test_cap;",""
"46","    test_args.max_mem = max_mem;",""
"47","",""
"48","    HANDLE* thd_lst = new HANDLE[thd_cnt];",""
"49","    for (int i=0; i<thd_cnt; ++i)",""
"50","    {",""
"51","        thd_lst[i] = ::CreateThread(NULL, 0, RAMDON_MALLOC_FREE_THD, ",""
"52","                            (LPVOID)(&test_args), CREATE_SUSPENDED, NULL);",""
"53","    }",""
"54","",""
"55","    for (int i=0; i<thd_cnt; ++i)",""
"56","        ::ResumeThread(thd_lst[i]);",""
"57","",""
"58","    ::WaitForMultipleObjects(thd_cnt, thd_lst, TRUE, INFINITE);",""
"59","    for (int i=0; i<thd_cnt; ++i)",""
"60","        ::CloseHandle(thd_lst[i]);",""
"61","",""
"62","    delete[] thd_lst;",""
"63","}",""
"64","",""
"65","void list_malloc_free(int test_cnt, int test_cap, int max_mem)",""
"66","{",""
"67","    typedef std::list<char*> POINT_LST;",""
"68","    POINT_LST test_lst;",""
"69","    for (int i=0; i<test_cnt; ++i)",""
"70","    {",""
"71","        int len = rand() * rand() % max_mem;","1.82034e-002"
"72","        char* block = new char[len];","0.1120551"
"73","        test_lst.push_back(block);","1.85965e-002"
"74","",""
"75","        while (test_lst.size() >= test_cap)",""
"76","        {",""
"77","            delete[] test_lst.front();",""
"78","            test_lst.pop_front();",""
"79","        }",""
"80","        if (rand() & 1)","8.326e-003"
"81","        {",""
"82","            delete[] test_lst.front();","9.0444e-003"
"83","            test_lst.pop_front();",""
"84","        }",""
"85","    }",""
"86","    while(!test_lst.empty())",""
"87","    {",""
"88","        delete[] test_lst.front();",""
"89","        test_lst.pop_front();",""
"90","    }",""
"91","}",""
