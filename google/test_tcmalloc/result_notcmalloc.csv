"Line","Source","CPU Time"
"1","#include ""test_func.h""",""
"2","",""
"3","void random_malloc_free(int test_cnt, int test_cap, int max_mem)",""
"4","{",""
"5","    typedef std::map<int, char*> POINT_MAP;",""
"6","    typedef POINT_MAP::iterator POINT_MAP_ITOR;",""
"7","    POINT_MAP test_map;",""
"8","    for(int i=0; i<test_cnt; ++i)",""
"9","    {",""
"10","        int rand_id = rand() % test_cap;",""
"11","        POINT_MAP_ITOR find_part = test_map.find(rand_id);","0.4258438"
"12","        if (find_part != test_map.end())",""
"13","        {",""
"14","            //printf(""free %d\n"", rand_id);",""
"15","            delete[] (find_part->second);","1.5408359"
"16","            test_map.erase(find_part);","0.1827917"
"17","        }",""
"18","        else",""
"19","        {",""
"20","            int len = rand() * rand() % max_mem;","8.06785e-002"
"21","            //printf(""malloc %d:%d\n"", rand_id, len);",""
"22","            char* block = new char[len];","1.3549476"
"23","            test_map[rand_id] = block;","0.2765691"
"24","        }",""
"25","    }",""
"26","",""
"27","    for(POINT_MAP_ITOR it = test_map.begin(); it != test_map.end(); ++it)",""
"28","    {",""
"29","        delete[] it->second;","1.66486e-002"
"30","    }",""
"31","}",""
"32","",""
"33","DWORD WINAPI RAMDON_MALLOC_FREE_THD(LPVOID p_param)",""
"34","{",""
"35","    RANDOM_MALLOC_FREE_ARGS* test_args = (RANDOM_MALLOC_FREE_ARGS*)p_param;",""
"36","    if (test_args == NULL) return 1;",""
"37","    random_malloc_free(test_args->test_cnt, test_args->test_cap, test_args->max_mem);","6.469e-002"
"38","    return 0;",""
"39","}",""
"40","",""
"41","void random_malloc_free_mthd(int thd_cnt, int test_cnt, int test_cap, int max_mem)",""
"42","{",""
"43","    RANDOM_MALLOC_FREE_ARGS test_args;",""
"44","    test_args.test_cnt = test_cnt;",""
"45","    test_args.test_cap = test_cap;",""
"46","    test_args.max_mem = max_mem;",""
"47","",""
"48","    HANDLE* thd_lst = new HANDLE[thd_cnt];",""
"49","    for (int i=0; i<thd_cnt; ++i)",""
"50","    {",""
"51","        thd_lst[i] = ::CreateThread(NULL, 0, RAMDON_MALLOC_FREE_THD, ",""
"52","                            (LPVOID)(&test_args), CREATE_SUSPENDED, NULL);",""
"53","    }",""
"54","",""
"55","    for (int i=0; i<thd_cnt; ++i)",""
"56","        ::ResumeThread(thd_lst[i]);",""
"57","",""
"58","    ::WaitForMultipleObjects(thd_cnt, thd_lst, TRUE, INFINITE);",""
"59","    for (int i=0; i<thd_cnt; ++i)",""
"60","        ::CloseHandle(thd_lst[i]);",""
"61","",""
"62","    delete[] thd_lst;",""
"63","}",""
"64","",""
"65","void list_malloc_free(int test_cnt, int test_cap, int max_mem)",""
"66","{",""
"67","    typedef std::list<char*> POINT_LST;",""
"68","    POINT_LST test_lst;",""
"69","    for (int i=0; i<test_cnt; ++i)",""
"70","    {",""
"71","        int len = rand() * rand() % max_mem;","4.11688e-002"
"72","        //printf(""malloc %d:%d\n"", rand_id, len);",""
"73","        char* block = new char[len];","0.424569"
"74","        test_lst.push_back(block);","4.51792e-002"
"75","",""
"76","        while (test_lst.size() >= test_cap)",""
"77","        {",""
"78","            delete[] test_lst.front();","0.2113524"
"79","            test_lst.pop_front();","1.44996e-002"
"80","        }",""
"81","        if (rand() & 1)",""
"82","        {",""
"83","            delete[] test_lst.front();","0.2449799"
"84","            test_lst.pop_front();","1.78722e-002"
"85","        }",""
"86","    }",""
"87","    while(!test_lst.empty())",""
"88","    {",""
"89","        delete[] test_lst.front();","9.4149e-003"
"90","        test_lst.pop_front();",""
"91","    }",""
"92","}",""
